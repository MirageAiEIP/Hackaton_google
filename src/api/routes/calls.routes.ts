import type { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { callService } from '@/services/call.service';
import { logger } from '@/utils/logger';

/**
 * Routes pour g√©rer les conversations web
 * Le frontend appelle ces routes, le backend g√®re tout
 * Architecture: Signed URL - Le frontend se connecte directement √† ElevenLabs
 */

// Store des conversations actives en m√©moire
const activeConversations = new Map<
  string,
  {
    callId: string;
    startedAt: Date;
    signedUrl: string;
  }
>();

export const callsRoutes: FastifyPluginAsync = async (app) => {
  logger.info('üìû Registering Calls Routes at /api/v1/calls');
  /**
   * GET /api/v1/calls/:callId/transcript
   * Get transcript for a call
   */
  app.get(
    '/:callId/transcript',
    {
      schema: {
        tags: ['calls'],
        summary: 'Get call transcript',
        params: {
          type: 'object',
          properties: {
            callId: { type: 'string' },
          },
          required: ['callId'],
        },
      },
    },
    async (request, reply) => {
      const { callId } = request.params as { callId: string };

      try {
        const call = await callService.getCallById(callId);

        if (!call) {
          return reply.status(404).send({
            success: false,
            error: 'Call not found',
          });
        }

        return {
          success: true,
          data: {
            callId: call.id,
            transcript: call.transcript || '',
            status: call.status,
            createdAt: call.createdAt,
          },
        };
      } catch (error) {
        logger.error('Failed to get transcript', error as Error, { callId });
        return reply.status(500).send({
          success: false,
          error: 'Failed to get transcript',
        });
      }
    }
  );

  /**
   * D√©marrer une nouvelle conversation web
   * Le frontend appelle cette route, le backend g√®re tout
   */
  app.post(
    '/start-web',
    {
      schema: {
        tags: ['calls'],
        summary: 'D√©marrer conversation web',
        description: "Lance une nouvelle conversation avec l'agent SAMU (backend g√®re tout)",
        body: {
          type: 'object',
          properties: {
            phoneNumber: {
              type: 'string',
              description: 'Num√©ro de t√©l√©phone du patient (optionnel)',
            },
            metadata: {
              type: 'object',
              description: 'M√©tadonn√©es additionnelles (optionnel)',
            },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              callId: { type: 'string' },
              sessionId: { type: 'string' },
              agentConfig: {
                type: 'object',
                properties: {
                  connectionType: { type: 'string' },
                  wsUrl: {
                    type: 'string',
                    description: 'WebSocket URL vers notre backend (pas ElevenLabs directement)',
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    },
    async (request, reply) => {
      logger.info('üéØ POST /api/v1/calls/start-web called');

      const bodySchema = z.object({
        phoneNumber: z.string().optional(),
        metadata: z.record(z.any()).optional(),
      });

      const body = bodySchema.parse(request.body);

      logger.info('üìû Starting web conversation', {
        phoneNumber: body.phoneNumber,
        hasMetadata: !!body.metadata,
      });

      try {
        // 1. Cr√©er l'appel en DB
        const call = await callService.createCall({
          phoneNumber: body.phoneNumber || 'WEB_CALL',
        });

        logger.info('Call created', { callId: call.id });

        // 2. G√©n√©rer un sessionId unique
        const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // 3. Stocker la conversation active
        activeConversations.set(sessionId, {
          callId: call.id,
          startedAt: new Date(),
          signedUrl: '', // Will be generated by WebSocket proxy
        });

        logger.info('Conversation initialized', {
          callId: call.id,
          sessionId,
        });

        const wsUrl =
          process.env.PUBLIC_API_URL?.replace('https://', 'wss://').replace('http://', 'ws://') ||
          'ws://localhost:8080';

        return {
          success: true,
          callId: call.id,
          sessionId,
          agentConfig: {
            connectionType: 'websocket',
            wsUrl: `${wsUrl}/ws/web-conversation?sessionId=${sessionId}&callId=${call.id}`,
          },
          message: 'Conversation d√©marr√©e avec succ√®s',
        };
      } catch (error) {
        logger.error('Failed to start web conversation', error as Error);
        reply.status(500 as 200).send({
          success: false,
          error: 'Failed to start conversation',
        });
        return;
      }
    }
  );
};
