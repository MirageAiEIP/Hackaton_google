import type { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { callService } from '@/services/call.service';
import { logger } from '@/utils/logger';

/**
 * Routes pour g√©rer les conversations web
 * Le frontend appelle ces routes, le backend g√®re tout
 * Architecture: Signed URL - Le frontend se connecte directement √† ElevenLabs
 */

// Store des conversations actives en m√©moire
const activeConversations = new Map<
  string,
  {
    callId: string;
    startedAt: Date;
    signedUrl: string;
  }
>();

export const callsRoutes: FastifyPluginAsync = async (app) => {
  logger.info('üìû Registering Calls Routes at /api/v1/calls');
  /**
   * D√©marrer une nouvelle conversation web
   * Le frontend appelle cette route, le backend g√®re tout
   */
  app.post(
    '/start-web',
    {
      schema: {
        tags: ['calls'],
        summary: 'D√©marrer conversation web',
        description: "Lance une nouvelle conversation avec l'agent SAMU (backend g√®re tout)",
        body: {
          type: 'object',
          properties: {
            phoneNumber: {
              type: 'string',
              description: 'Num√©ro de t√©l√©phone du patient (optionnel)',
            },
            metadata: {
              type: 'object',
              description: 'M√©tadonn√©es additionnelles (optionnel)',
            },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              callId: { type: 'string' },
              sessionId: { type: 'string' },
              agentConfig: {
                type: 'object',
                properties: {
                  connectionType: { type: 'string' },
                  wsUrl: {
                    type: 'string',
                    description: 'WebSocket URL vers notre backend (pas ElevenLabs directement)',
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    },
    async (request, reply) => {
      logger.info('üéØ POST /api/v1/calls/start-web called');

      const bodySchema = z.object({
        phoneNumber: z.string().optional(),
        metadata: z.record(z.any()).optional(),
      });

      const body = bodySchema.parse(request.body);

      logger.info('üìû Starting web conversation', {
        phoneNumber: body.phoneNumber,
        hasMetadata: !!body.metadata,
      });

      try {
        // 1. Cr√©er l'appel en DB
        const call = await callService.createCall({
          phoneNumber: body.phoneNumber || 'WEB_CALL',
        });

        logger.info('Call created', { callId: call.id });

        // 2. G√©n√©rer un sessionId unique
        const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // 3. Stocker la conversation active
        activeConversations.set(sessionId, {
          callId: call.id,
          startedAt: new Date(),
          signedUrl: '', // Will be generated by WebSocket proxy
        });

        logger.info('Conversation initialized', {
          callId: call.id,
          sessionId,
        });

        // 4. Retourner l'URL du WebSocket backend (pas la signed URL ElevenLabs!)
        // Frontend se connecte √† NOTRE WebSocket, qui fait proxy vers ElevenLabs
        const wsUrl =
          process.env.PUBLIC_API_URL?.replace('https://', 'wss://').replace('http://', 'ws://') ||
          'ws://localhost:3000';

        return {
          success: true,
          callId: call.id,
          sessionId,
          agentConfig: {
            connectionType: 'websocket',
            wsUrl: `${wsUrl}/ws/web-conversation?sessionId=${sessionId}&callId=${call.id}`,
          },
          message: 'Conversation d√©marr√©e avec succ√®s',
        };
      } catch (error) {
        logger.error('Failed to start web conversation', error as Error);
        reply.status(500 as 200).send({
          success: false,
          error: 'Failed to start conversation',
        });
        return;
      }
    }
  );

  /**
   * Obtenir le statut d'une conversation
   */
  app.get(
    '/:sessionId/status',
    {
      schema: {
        tags: ['calls'],
        summary: 'Statut de la conversation',
        description: "R√©cup√®re le statut d'une conversation en cours",
        params: {
          type: 'object',
          required: ['sessionId'],
          properties: {
            sessionId: { type: 'string' },
          },
        },
      },
    },
    async (request, reply) => {
      const { sessionId } = request.params as { sessionId: string };

      const activeConv = activeConversations.get(sessionId);

      if (!activeConv) {
        return reply.status(404).send({
          success: false,
          error: 'Conversation not found',
        });
      }

      return {
        success: true,
        sessionId,
        callId: activeConv.callId,
        startedAt: activeConv.startedAt.toISOString(),
        duration: Math.floor((Date.now() - activeConv.startedAt.getTime()) / 1000),
        status: 'active',
      };
    }
  );

  /**
   * Terminer une conversation
   */
  app.post(
    '/:sessionId/stop',
    {
      schema: {
        tags: ['calls'],
        summary: 'Terminer la conversation',
        description: 'Arr√™te proprement une conversation en cours',
        params: {
          type: 'object',
          required: ['sessionId'],
          properties: {
            sessionId: { type: 'string' },
          },
        },
      },
    },
    async (request, reply) => {
      const { sessionId } = request.params as { sessionId: string };

      logger.info('Stopping conversation', { sessionId });

      const activeConv = activeConversations.get(sessionId);

      if (!activeConv) {
        return reply.status(404).send({
          success: false,
          error: 'Conversation not found',
        });
      }

      try {
        // Arr√™ter la conversation ElevenLabs
        // await activeConv.conversation.endSession();

        // Mettre √† jour le statut dans la DB
        await callService.updateCallStatus(activeConv.callId, 'COMPLETED');

        // Supprimer de la liste active
        activeConversations.delete(sessionId);

        logger.info('Conversation stopped', {
          sessionId,
          callId: activeConv.callId,
        });

        return {
          success: true,
          message: 'Conversation termin√©e avec succ√®s',
        };
      } catch (error) {
        logger.error('Failed to stop conversation', error as Error, { sessionId });
        return reply.status(500).send({
          success: false,
          error: 'Failed to stop conversation',
        });
      }
    }
  );
};
