/**
 * TESTS D'INT√âGRATION R√âELS - AUCUN MOCK
 * Teste les vrais workflows de bout en bout avec de vraies donn√©es
 */

import axios, { AxiosInstance } from 'axios';
import { faker } from '@faker-js/faker';

const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

// Couleurs pour terminal
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
};

interface TestData {
  operators: Array<{ id: string; name: string; email: string }>;
  calls: Array<{ id: string; sessionId: string; phoneNumber: string }>;
  dispatches: Array<{ id: string; dispatchId: string; priority: string }>;
  queueEntries: Array<{ id: string; callId: string }>;
  handoffs: Array<{ id: string; callId: string }>;
}

class RealIntegrationTester {
  private client: AxiosInstance;
  private testData: TestData = {
    operators: [],
    calls: [],
    dispatches: [],
    queueEntries: [],
    handoffs: [],
  };

  constructor() {
    this.client = axios.create({
      baseURL: BASE_URL,
      timeout: 30000,
      validateStatus: () => true,
    });
  }

  private log(message: string, color: keyof typeof colors = 'reset') {
    // eslint-disable-next-line no-console
    console.log(`${colors[color]}${message}${colors.reset}`);
  }

  private logData(label: string, data: unknown) {
    this.log(`\nüìã ${label}:`, 'cyan');
    // eslint-disable-next-line no-console
    console.log(JSON.stringify(data, null, 2));
  }

  /**
   * WORKFLOW 1: Cr√©er des op√©rateurs r√©els
   */
  async testCreateRealOperators() {
    this.log('\nüß™ WORKFLOW 1: Cr√©er 3 op√©rateurs r√©els dans la base', 'magenta');

    for (let i = 0; i < 3; i++) {
      const name = faker.person.fullName();
      const email = faker.internet.email();

      this.log(`\n‚û°Ô∏è  Cr√©ation op√©rateur ${i + 1}: ${name} (${email})`, 'cyan');

      const res = await this.client.post('/api/v1/operators', { name, email });

      if (res.status !== 200 && res.status !== 201) {
        this.log(`‚ùå ERREUR cr√©ation op√©rateur: ${res.status}`, 'red');
        this.logData('R√©ponse', res.data);
        throw new Error('√âchec cr√©ation op√©rateur');
      }

      const operator = res.data.data.operator;
      this.testData.operators.push(operator);

      this.log(`‚úÖ Op√©rateur cr√©√©: ${operator.name} (ID: ${operator.id})`, 'green');
      this.logData('Op√©rateur', operator);
    }

    this.log(`\n‚úÖ ${this.testData.operators.length} op√©rateurs cr√©√©s avec succ√®s`, 'green');
  }

  /**
   * WORKFLOW 2: Mettre les op√©rateurs AVAILABLE
   */
  async testSetOperatorsAvailable() {
    this.log('\nüß™ WORKFLOW 2: Mettre tous les op√©rateurs AVAILABLE', 'magenta');

    for (const operator of this.testData.operators) {
      this.log(`\n‚û°Ô∏è  Mise √† jour statut: ${operator.name} ‚Üí AVAILABLE`, 'cyan');

      const res = await this.client.patch(`/api/v1/operators/${operator.id}/status`, {
        status: 'AVAILABLE',
      });

      if (res.status !== 200) {
        this.log(`‚ùå ERREUR mise √† jour statut: ${res.status}`, 'red');
        this.logData('R√©ponse', res.data);
        throw new Error('√âchec mise √† jour statut');
      }

      this.log(`‚úÖ ${operator.name} est maintenant AVAILABLE`, 'green');
    }

    // V√©rifier que les op√©rateurs sont bien disponibles
    this.log('\n‚û°Ô∏è  V√©rification des op√©rateurs disponibles...', 'cyan');
    const res = await this.client.get('/api/v1/operators/available');

    this.log(`‚úÖ ${res.data.data.operators.length} op√©rateurs disponibles`, 'green');
    this.logData('Op√©rateurs disponibles', res.data.data.operators);
  }

  /**
   * WORKFLOW 3: Cr√©er de vraies conversations
   */
  async testCreateRealConversations() {
    this.log('\nüß™ WORKFLOW 3: Cr√©er 5 vraies conversations web', 'magenta');

    for (let i = 0; i < 5; i++) {
      const phoneNumber = faker.phone.number('+336########');

      this.log(`\n‚û°Ô∏è  D√©marrage conversation ${i + 1}: ${phoneNumber}`, 'cyan');

      const res = await this.client.post('/api/v1/calls/start-web', {
        phoneNumber,
        metadata: {
          source: 'integration-test',
          testNumber: i + 1,
          timestamp: new Date().toISOString(),
        },
      });

      if (res.status !== 200) {
        this.log(`‚ùå ERREUR d√©marrage conversation: ${res.status}`, 'red');
        this.logData('R√©ponse', res.data);
        throw new Error('√âchec d√©marrage conversation');
      }

      const call = {
        id: res.data.callId,
        sessionId: res.data.sessionId,
        phoneNumber,
        signedUrl: res.data.agentConfig.signedUrl,
      };

      this.testData.calls.push(call);

      this.log(`‚úÖ Conversation cr√©√©e: ${call.sessionId}`, 'green');
      this.log(`   Call ID: ${call.id}`, 'cyan');
      this.log(`   Phone: ${call.phoneNumber}`, 'cyan');
      this.log(`   Signed URL: ${call.signedUrl.substring(0, 80)}...`, 'cyan');

      // V√©rifier le statut
      const statusRes = await this.client.get(`/api/v1/calls/${call.sessionId}/status`);
      this.logData('Statut conversation', statusRes.data);
    }

    this.log(`\n‚úÖ ${this.testData.calls.length} conversations cr√©√©es`, 'green');
  }

  /**
   * WORKFLOW 4: Cr√©er de vrais dispatches SMUR
   */
  async testCreateRealDispatches() {
    this.log('\nüß™ WORKFLOW 4: Cr√©er 2 vrais dispatches SMUR (urgences P0/P1 seulement)', 'magenta');
    this.log('‚ÑπÔ∏è  Note: SMUR = Urgences vitales (P0/P1 uniquement)', 'yellow');

    const priorities = ['P0', 'P1'];
    const locations = [
      '15 Avenue des Champs-√âlys√©es, 75008 Paris',
      '5 Rue de la Paix, 75002 Paris',
    ];

    for (let i = 0; i < 2; i++) {
      const phoneNumber = faker.phone.number('+336########');

      this.log(`\n‚û°Ô∏è  Dispatch ${i + 1}: ${priorities[i]} - ${locations[i]}`, 'cyan');

      const res = await this.client.post('/api/v1/test/dispatch-smur', {
        priority: priorities[i],
        location: locations[i],
        reason: `${priorities[i]} - ${faker.lorem.sentence()}`,
        patientPhone: phoneNumber,
      });

      if (res.status !== 200) {
        this.log(`‚ùå ERREUR dispatch SMUR: ${res.status}`, 'red');
        this.logData('R√©ponse', res.data);
        throw new Error('√âchec dispatch SMUR');
      }

      const dispatch = {
        id: res.data.id,
        dispatchId: res.data.dispatchId,
        priority: priorities[i],
        location: locations[i],
        callId: res.data.callId,
      };

      this.testData.dispatches.push(dispatch);

      this.log(`‚úÖ Dispatch cr√©√©: ${dispatch.dispatchId}`, 'green');
      this.logData('Dispatch', dispatch);
    }

    // R√©cup√©rer tous les dispatches
    this.log('\n‚û°Ô∏è  R√©cup√©ration de tous les dispatches...', 'cyan');
    const res = await this.client.get('/api/v1/test/dispatches');
    this.log(`‚úÖ ${res.data.dispatches.length} dispatches au total`, 'green');
    this.logData('Tous les dispatches', res.data.dispatches);
  }

  /**
   * WORKFLOW 5: R√©cup√©rer les vraies conversations ElevenLabs
   */
  async testGetRealElevenLabsConversations() {
    this.log('\nüß™ WORKFLOW 5: R√©cup√©rer les vraies conversations ElevenLabs API', 'magenta');

    this.log('\n‚û°Ô∏è  Appel √† ElevenLabs API...', 'cyan');

    const res = await this.client.get('/api/v1/test/conversations', {
      params: {
        page_size: 10,
      },
    });

    if (res.status !== 200) {
      this.log(`‚ùå ERREUR r√©cup√©ration conversations: ${res.status}`, 'red');
      this.logData('R√©ponse', res.data);
      return; // Ne pas fail, peut ne pas avoir de conversations
    }

    this.log(`‚úÖ ${res.data.count} conversations trouv√©es`, 'green');
    this.logData('Conversations ElevenLabs', {
      count: res.data.count,
      has_more: res.data.has_more,
      conversations: res.data.conversations?.slice(0, 3), // Premi√®re 3 seulement
    });

    // Si on a des conversations, tester le d√©tail
    if (res.data.conversations && res.data.conversations.length > 0) {
      const firstConv = res.data.conversations[0];
      this.log(`\n‚û°Ô∏è  R√©cup√©ration d√©tails conversation: ${firstConv.conversation_id}`, 'cyan');

      const detailRes = await this.client.get(
        `/api/v1/test/conversations/${firstConv.conversation_id}`
      );

      if (detailRes.status === 200) {
        this.log(`‚úÖ D√©tails conversation r√©cup√©r√©s`, 'green');
        this.logData('D√©tails', {
          conversation_id: detailRes.data.conversation?.conversation_id,
          agent_id: detailRes.data.conversation?.agent_id,
          status: detailRes.data.conversation?.status,
          transcript_preview: detailRes.data.formattedTranscript?.substring(0, 200) + '...',
        });
      }
    }
  }

  /**
   * WORKFLOW 6: Tester la queue de bout en bout
   */
  async testQueueWorkflow() {
    this.log('\nüß™ WORKFLOW 6: Workflow complet de la queue', 'magenta');

    // 1. V√©rifier la queue actuelle
    this.log('\n‚û°Ô∏è  R√©cup√©ration de la queue...', 'cyan');
    const queueRes = await this.client.get('/api/v1/test/queue');

    this.log(`‚úÖ ${queueRes.data.count} entr√©es dans la queue`, 'green');
    this.logData('Queue', queueRes.data.queue);

    // 2. Si on a des entr√©es, tester le claim
    if (queueRes.data.queue && queueRes.data.queue.length > 0 && this.testData.operators.length > 0) {
      const queueEntry = queueRes.data.queue[0];
      const operator = this.testData.operators[0];

      this.log(`\n‚û°Ô∏è  Op√©rateur ${operator.name} claim l'appel ${queueEntry.id}`, 'cyan');

      const claimRes = await this.client.post(`/api/v1/test/queue/${queueEntry.id}/claim`, {
        operatorId: operator.id,
      });

      if (claimRes.status === 200) {
        this.log(`‚úÖ Appel claim avec succ√®s!`, 'green');
        this.logData('Queue entry claim√©e', claimRes.data.queueEntry);
      } else {
        this.log(`‚ö†Ô∏è  Appel d√©j√† claim ou non disponible (${claimRes.status})`, 'yellow');
      }
    } else {
      this.log(`‚ÑπÔ∏è  Aucune entr√©e dans la queue pour tester le claim`, 'yellow');
    }
  }

  /**
   * WORKFLOW 7: Tester les handoffs
   */
  async testHandoffWorkflow() {
    this.log('\nüß™ WORKFLOW 7: Workflow complet des handoffs AI ‚Üí Humain', 'magenta');

    // 1. R√©cup√©rer les handoffs pending
    this.log('\n‚û°Ô∏è  R√©cup√©ration des handoffs pending...', 'cyan');
    const pendingRes = await this.client.get('/api/v1/handoff/pending');

    this.log(`‚úÖ ${pendingRes.data.count} handoffs pending`, 'green');
    this.logData('Handoffs pending', pendingRes.data.data);

    // 2. Si on a des appels actifs et des op√©rateurs, cr√©er un handoff via le tool
    if (this.testData.calls.length > 0 && this.testData.operators.length > 0) {
      const call = this.testData.calls[0];
      const operator = this.testData.operators[1]; // Prendre le 2√®me op√©rateur

      this.log(
        `\n‚û°Ô∏è  Cr√©ation handoff pour call ${call.id} vers op√©rateur ${operator.name}`,
        'cyan'
      );

      const handoffRes = await this.client.post('/api/v1/tools/request_human_handoff', {
        callId: call.id,
        conversationId: call.sessionId,
        reason: 'Test d\'int√©gration - Patient demande un humain',
        transcript: 'AI: Bonjour, je suis l\'assistant SAMU.\nPatient: Je veux parler √† un humain.',
        patientSummary: 'Patient souhaite parler √† un op√©rateur humain pour discuter de sympt√¥mes complexes.',
        aiContext: {
          symptoms: ['douleur thoracique', 'essoufflement'],
          priority: 'P3',
          urgency: 'moderate',
        },
      });

      if (handoffRes.status === 200 && handoffRes.data.success) {
        const handoff = {
          id: handoffRes.data.handoffId,
          callId: call.id,
          status: handoffRes.data.status,
        };

        this.testData.handoffs.push(handoff);

        this.log(`‚úÖ Handoff cr√©√©: ${handoff.id}`, 'green');
        this.logData('Handoff cr√©√©', handoffRes.data);

        // 3. Accepter le handoff
        this.log(`\n‚û°Ô∏è  Op√©rateur ${operator.name} accepte le handoff ${handoff.id}`, 'cyan');

        const acceptRes = await this.client.post(`/api/v1/handoff/${handoff.id}/accept`, {
          operatorId: operator.id,
        });

        if (acceptRes.status === 200) {
          this.log(`‚úÖ Handoff accept√© avec succ√®s!`, 'green');
          this.logData('Handoff accept√©', acceptRes.data);

          // 4. R√©cup√©rer les d√©tails du handoff
          this.log(`\n‚û°Ô∏è  R√©cup√©ration d√©tails handoff ${handoff.id}`, 'cyan');

          const detailsRes = await this.client.get(`/api/v1/handoff/${handoff.id}`);

          if (detailsRes.status === 200) {
            this.log(`‚úÖ D√©tails handoff r√©cup√©r√©s`, 'green');
            this.logData('D√©tails handoff', detailsRes.data.data);
          }

          // 5. Compl√©ter le handoff
          this.log(`\n‚û°Ô∏è  Compl√©tion du handoff ${handoff.id}`, 'cyan');

          const completeRes = await this.client.post(`/api/v1/handoff/${handoff.id}/complete`);

          if (completeRes.status === 200) {
            this.log(`‚úÖ Handoff compl√©t√© avec succ√®s!`, 'green');
          }
        } else {
          this.log(`‚ö†Ô∏è  Erreur acceptation handoff: ${acceptRes.status}`, 'yellow');
          this.logData('Erreur', acceptRes.data);
        }
      } else {
        this.log(`‚ö†Ô∏è  Erreur cr√©ation handoff: ${handoffRes.status}`, 'yellow');
        this.logData('Erreur', handoffRes.data);
      }
    }
  }

  /**
   * WORKFLOW 8: Tester les tools ElevenLabs avec vraies donn√©es
   */
  async testElevenLabsTools() {
    this.log('\nüß™ WORKFLOW 8: Tester les tools ElevenLabs avec vraies donn√©es', 'magenta');

    // 1. Test get_patient_history avec un vrai hash
    this.log('\n‚û°Ô∏è  Test get_patient_history...', 'cyan');

    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const crypto = require('crypto');
    const phoneHash = crypto.createHash('sha256').update('+33612345678').digest('hex');

    const historyRes = await this.client.post('/api/v1/tools/get_patient_history', {
      phoneHash,
    });

    this.log(`‚úÖ Patient history r√©cup√©r√©`, 'green');
    this.logData('Patient history', historyRes.data);

    // 2. Test get_pharmacy_on_duty avec vraies coordonn√©es Paris
    this.log('\n‚û°Ô∏è  Test get_pharmacy_on_duty (Paris)...', 'cyan');

    const pharmacyRes = await this.client.post('/api/v1/tools/get_pharmacy_on_duty', {
      latitude: 48.8566,
      longitude: 2.3522,
      city: 'Paris',
      postalCode: '75001',
    });

    this.log(`‚úÖ Pharmacies trouv√©es`, 'green');
    this.logData('Pharmacies', pharmacyRes.data);
  }

  /**
   * WORKFLOW 9: Tester la carte temps r√©el
   */
  async testRealtimeMap() {
    this.log('\nüß™ WORKFLOW 9: Tester les donn√©es carte temps r√©el', 'magenta');

    this.log('\n‚û°Ô∏è  R√©cup√©ration donn√©es carte...', 'cyan');

    const mapRes = await this.client.get('/api/v1/test/interventions/map', {
      params: {
        last_hours: 24,
      },
    });

    this.log(`‚úÖ ${mapRes.data.count} interventions sur la carte`, 'green');
    this.logData('Donn√©es carte', {
      count: mapRes.data.count,
      dispatches: mapRes.data.dispatches,
      geoJson: mapRes.data.geoJson?.features?.slice(0, 3), // Premiers 3 points
    });
  }

  /**
   * WORKFLOW 10: Tester les calls actifs et dashboard
   */
  async testActiveCalls() {
    this.log('\nüß™ WORKFLOW 10: Tester calls actifs et dashboard', 'magenta');

    // 1. R√©cup√©rer les calls actifs
    this.log('\n‚û°Ô∏è  R√©cup√©ration calls actifs...', 'cyan');

    const activeRes = await this.client.get('/api/v1/test/calls/active');

    this.log(`‚úÖ ${activeRes.data.count} calls actifs`, 'green');
    this.logData('Calls actifs', activeRes.data.calls);

    // 2. R√©cup√©rer les stats dashboard
    this.log('\n‚û°Ô∏è  R√©cup√©ration stats dashboard...', 'cyan');

    const statsRes = await this.client.get('/api/v1/dashboard/stats');

    this.log(`‚úÖ Stats dashboard r√©cup√©r√©es`, 'green');
    this.logData('Dashboard stats', statsRes.data);
  }

  /**
   * R√©sum√© final des donn√©es cr√©√©es
   */
  printSummary() {
    this.log('\n' + '='.repeat(80), 'blue');
    this.log('üìä R√âSUM√â DES TESTS D\'INT√âGRATION R√âELS', 'blue');
    this.log('='.repeat(80), 'blue');

    this.log(`\n‚úÖ Op√©rateurs cr√©√©s: ${this.testData.operators.length}`, 'green');
    this.testData.operators.forEach((op, i) => {
      this.log(`   ${i + 1}. ${op.name} (${op.email}) - ID: ${op.id}`, 'cyan');
    });

    this.log(`\n‚úÖ Conversations cr√©√©es: ${this.testData.calls.length}`, 'green');
    this.testData.calls.forEach((call, i) => {
      this.log(`   ${i + 1}. ${call.phoneNumber} - Session: ${call.sessionId}`, 'cyan');
    });

    this.log(`\n‚úÖ Dispatches SMUR cr√©√©s: ${this.testData.dispatches.length}`, 'green');
    this.testData.dispatches.forEach((dispatch, i) => {
      this.log(
        `   ${i + 1}. ${dispatch.priority} - ${dispatch.location.substring(0, 40)}...`,
        'cyan'
      );
    });

    this.log(`\n‚úÖ Handoffs cr√©√©s: ${this.testData.handoffs.length}`, 'green');
    this.testData.handoffs.forEach((handoff, i) => {
      this.log(`   ${i + 1}. Handoff ${handoff.id} - Call: ${handoff.callId}`, 'cyan');
    });

    this.log('\n' + '='.repeat(80), 'blue');
    this.log('üéâ TOUS LES TESTS D\'INT√âGRATION R√âELS TERMIN√âS AVEC SUCC√àS!', 'green');
    this.log('='.repeat(80), 'blue');
  }

  /**
   * Ex√©cuter tous les workflows
   */
  async runAllWorkflows() {
    this.log('üöÄ D√âMARRAGE DES TESTS D\'INT√âGRATION R√âELS', 'blue');
    this.log(`üìç Base URL: ${BASE_URL}`, 'blue');
    this.log('='.repeat(80), 'blue');
    this.log('‚ö†Ô∏è  ATTENTION: Ces tests cr√©ent de VRAIES donn√©es dans la base!', 'yellow');
    this.log('='.repeat(80), 'blue');

    try {
      // V√©rifier que le serveur est accessible
      await this.client.get('/health');
      this.log('‚úÖ Serveur accessible\n', 'green');

      await this.testCreateRealOperators();
      await this.testSetOperatorsAvailable();
      await this.testCreateRealConversations();
      await this.testCreateRealDispatches();
      await this.testGetRealElevenLabsConversations();
      await this.testQueueWorkflow();
      await this.testHandoffWorkflow();
      await this.testElevenLabsTools();
      await this.testRealtimeMap();
      await this.testActiveCalls();

      this.printSummary();

      process.exit(0);
    } catch (error) {
      this.log('\n‚ùå ERREUR FATALE DANS LES TESTS', 'red');
      console.error(error);
      process.exit(1);
    }
  }
}

// Ex√©cuter
const tester = new RealIntegrationTester();
tester.runAllWorkflows().catch((error) => {
  console.error('Erreur fatale:', error);
  process.exit(1);
});
